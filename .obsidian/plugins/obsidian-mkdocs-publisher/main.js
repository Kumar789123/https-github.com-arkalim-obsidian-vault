/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook2) {
      var orig = hook2;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook2 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook2 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook2 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        };
      }
      state.registry[name].push({
        hook: hook2,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook2, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register.bind(null, state);
      bindApi(hook2, state);
      return hook2;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var global = getGlobal();
    module2.exports = exports = global.fetch;
    if (global.fetch) {
      exports.default = global.fetch.bind(global);
    }
    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// mkdocsPublisher/main.ts
__export(exports, {
  default: () => MkdocsPublication
});
var import_obsidian5 = __toModule(require("obsidian"));

// mkdocsPublisher/settings.ts
var import_obsidian = __toModule(require("obsidian"));

// mkdocsPublisher/settings/stylesSettings.ts
function showSettings(containerEl) {
  containerEl.descEl.show();
  containerEl.nameEl.show();
  containerEl.controlEl.show();
}
function hideSettings(containerEl) {
  containerEl.descEl.hide();
  containerEl.nameEl.hide();
  containerEl.controlEl.hide();
}
function autoCleanCondition(value, autoCleanSetting, plugin) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    if (value.length === 0 && settings.downloadedFolder === "yamlFrontmatter") {
      settings.autoCleanUp = false;
      yield plugin.saveSettings();
      autoCleanSetting.setDisabled(true);
      autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    } else if (value.length === 0 && settings.downloadedFolder !== "yamlFrontmatter") {
      settings.autoCleanUp = false;
      autoCleanSetting.setDisabled(true);
      autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    } else {
      autoCleanSetting.setDisabled(false);
      if (settings.autoCleanUp) {
        autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
      }
    }
  });
}
function yamlFrontmatterSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, value, plugin) {
  return __async(this, null, function* () {
    const settings = plugin.settings;
    if (value == "yamlFrontmatter") {
      showSettings(frontmatterKeySettings);
      showSettings(rootFolderSettings);
      autoCleanCondition(settings.rootFolder, autoCleanSetting, plugin).then();
    } else {
      if (settings.folderDefaultName.length > 0) {
        autoCleanSetting.setDisabled(false);
        if (settings.autoCleanUp) {
          autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
        }
      }
      hideSettings(frontmatterKeySettings);
      hideSettings(rootFolderSettings);
    }
  });
}
function autoCleanUpSettingsOnCondition(condition, autoCleanSetting, plugin) {
  const settings = plugin.settings;
  if (condition) {
    autoCleanSetting.setDisabled(true);
    autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    settings.autoCleanUp = false;
    plugin.saveSettings().then();
  } else {
    autoCleanSetting.setDisabled(false);
    if (settings.autoCleanUp) {
      autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
    }
  }
}

// mkdocsPublisher/settings.ts
var MkdocsSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Github Configuration" });
    containerEl.createEl("h2", { text: "Github settings" });
    new import_obsidian.Setting(containerEl).setName("Repo Name").setDesc("The name of the repository where you store your blog.").addText((text) => text.setPlaceholder("mkdocs-template").setValue(this.plugin.settings.githubRepo).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubRepo = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Github Username").setDesc("Your github username.").addText((text) => text.setPlaceholder("Github-username").setValue(this.plugin.settings.githubName).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubName = value.trim();
      yield this.plugin.saveSettings();
    })));
    const desc_ghToken = document.createDocumentFragment();
    desc_ghToken.createEl("span", null, (span) => {
      span.innerText = "A github token with repository permission. You can generate it ";
      span.createEl("a", null, (link) => {
        link.innerText = "here";
        link.href = "https://github.com/settings/tokens/new?scopes=repo,workflow";
      });
    });
    new import_obsidian.Setting(containerEl).setName("Github Token").setDesc(desc_ghToken).addText((text) => text.setPlaceholder("ghb-15457498545647987987112184").setValue(this.plugin.settings.GhToken).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.GhToken = value.trim();
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Download configuration" });
    containerEl.createEl("h5", { text: "Folder reception settings" });
    new import_obsidian.Setting(this.containerEl).setName("Folder Reception settings").setDesc("Choose between a fixed folder or the value of a frontmatter key.").addDropdown((dropDown) => {
      dropDown.addOptions({
        fixedFolder: "Fixed Folder",
        yamlFrontmatter: "YAML frontmatter",
        obsidianPath: "Obsidian Path"
      }).setValue(this.plugin.settings.downloadedFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.downloadedFolder = value;
        yield yamlFrontmatterSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, value, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(this.containerEl).setName("Default Folder").setDesc("Set the default reception folder").addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.folderDefaultName).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.folderDefaultName = value.replace(/\/$/, "");
        yield autoCleanCondition(value, autoCleanSetting, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    const frontmatterKeySettings = new import_obsidian.Setting(this.containerEl).setName("Frontmatter key").setClass("mdkocs-settings-tab").setDesc("Set the key where to get the value of the folder").addText((text) => {
      text.setPlaceholder("category").setValue(this.plugin.settings.yamlFolderKey).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.yamlFolderKey = value.trim();
        yield this.plugin.saveSettings();
      }));
    });
    const rootFolderSettings = new import_obsidian.Setting(this.containerEl).setName("Root folder").setClass("mdkocs-settings-tab").setDesc("Append this path to the folder set by the frontmatter key.").addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.rootFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.rootFolder = value.replace(/\/$/, "");
        yield autoCleanCondition(value, autoCleanSetting, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h5", { text: "Workflow" });
    new import_obsidian.Setting(containerEl).setName("Github action name").setDesc("If you want to activate a github action when the plugin push the file, set the name of the file (in your.github/worfklows folder).").addText((text) => {
      text.setPlaceholder("ci").setValue(this.plugin.settings.workflowName).onChange((value) => __async(this, null, function* () {
        value = value.length > 0 ? value.trim().replace(".yml", "") + ".yml" : value;
        this.plugin.settings.workflowName = value;
        yield this.plugin.saveSettings();
      }));
    });
    const condition = this.plugin.settings.downloadedFolder === "yamlFrontmatter" && this.plugin.settings.rootFolder.length === 0 || this.plugin.settings.folderDefaultName.length === 0;
    const autoCleanSetting = new import_obsidian.Setting(containerEl).setName("Auto clean up").setDesc("If the plugin must remove from github the removed files (stop share or deleted)").setDisabled(condition).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoCleanUp).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoCleanUp = value;
        if (value) {
          showSettings(autoCleanExcludedSettings);
        } else {
          hideSettings(autoCleanExcludedSettings);
        }
        yield this.plugin.saveSettings();
      }));
    });
    const autoCleanExcludedSettings = new import_obsidian.Setting(containerEl).setName("Excluded files").setDesc("If you want to exclude some folder from the auto clean up, set their path.").addTextArea((textArea) => {
      textArea.setPlaceholder("docs/assets/js, docs/assets/logo").setValue(this.plugin.settings.autoCleanUpExcluded).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoCleanUpExcluded = value;
        yield this.plugin.saveSettings();
      }));
    });
    if (this.plugin.settings.autoCleanUp) {
      showSettings(autoCleanExcludedSettings);
    } else {
      hideSettings(autoCleanExcludedSettings);
    }
    containerEl.createEl("h5", { text: "Embedded files" });
    new import_obsidian.Setting(containerEl).setName("Transfer image").setDesc("Send image linked to a file in github").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.transferEmbedded).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.transferEmbedded = value;
        value ? showSettings(settingsDefaultImage) : hideSettings(settingsDefaultImage);
        yield this.plugin.saveSettings();
      }));
    });
    const settingsDefaultImage = new import_obsidian.Setting(containerEl).setName("Default image folder").setDesc("To use a folder different from default").addText((text) => {
      text.setPlaceholder("docs/images").setValue(this.plugin.settings.defaultImageFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.defaultImageFolder = value.replace(/\/$/, "");
        yield this.plugin.saveSettings();
      }));
    });
    containerEl.createEl("h1", { text: "Plugin Settings" });
    new import_obsidian.Setting(containerEl).setName("Share Key").setDesc("The frontmatter key to publish your file on the website.").addText((text) => text.setPlaceholder("share").setValue(this.plugin.settings.shareKey).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shareKey = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Excluded Folder").setDesc("Never publish file in these folder, regardless of the share key. Separate folder name by comma.").addTextArea((textArea) => textArea.setPlaceholder("_assets, Archive").setValue(this.plugin.settings.ExcludedFolder).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ExcludedFolder = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("File Menu").setDesc("Add an sharing commands in the file menu").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.fileMenu = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Editor Menu").setDesc("Add a sharing commands in the right-click menu").addToggle((toggle) => toggle.setValue(this.plugin.settings.editorMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.editorMenu = value;
      yield this.plugin.saveSettings();
    })));
    autoCleanUpSettingsOnCondition(condition, autoCleanSetting, this.plugin);
    yamlFrontmatterSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, this.plugin.settings.downloadedFolder, this.plugin).then();
    this.plugin.settings.transferEmbedded ? showSettings(settingsDefaultImage) : hideSettings(settingsDefaultImage);
  }
};

// mkdocsPublisher/utils/status_bar.ts
var ShareStatusBar = class {
  constructor(statusBarItem, numberOfNotesToPublish) {
    this.statusBarItem = statusBarItem;
    this.counter = 0;
    this.numberOfNotesToPublish = numberOfNotesToPublish;
    this.statusBarItem.createEl("span", { text: "Mkdocs Publication: " });
    this.status = this.statusBarItem.createEl("span", { text: `${this.numberOfNotesToPublish} files marked for sharing` });
  }
  increment() {
    this.status.setText(`\u231BSharing Notes: ${++this.counter}/${this.numberOfNotesToPublish}`);
  }
  finish(displayDurationMillisec) {
    this.status.setText(`\u2705 Published Notes: ${this.counter}/${this.numberOfNotesToPublish}`);
    setTimeout(() => {
      this.statusBarItem.remove();
    }, displayDurationMillisec);
  }
  error() {
    this.statusBarItem.remove();
  }
};

// mkdocsPublisher/githubInteraction/upload.ts
var import_obsidian3 = __toModule(require("obsidian"));

// mkdocsPublisher/githubInteraction/getFiles.ts
var GetFiles = class {
  constructor(vault, metadataCache, settings, octokit) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
    this.octokit = octokit;
  }
  getSharedFiles() {
    const files = this.vault.getMarkdownFiles();
    const shared_File = [];
    const sharedkey = this.settings.shareKey;
    for (const file of files) {
      try {
        const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
        if (frontMatter && frontMatter[sharedkey] === true) {
          shared_File.push(file);
        }
      } catch (e) {
      }
    }
    return shared_File;
  }
  getAllFileWithPath() {
    const files = this.vault.getFiles();
    const allFileWithPath = [];
    const shareKey = this.settings.shareKey;
    for (const file of files) {
      const fileExtension = file.extension;
      if (fileExtension.match(/(png|jpe?g|svg|bmp|gif)$/i)) {
        const filepath = this.settings.defaultImageFolder.length > 0 ? this.settings.defaultImageFolder + "/" + file.path : this.settings.folderDefaultName.length > 0 ? this.settings.folderDefaultName + "/" + file.path : file.path;
        allFileWithPath.push(filepath);
      } else if (file.extension == "md") {
        const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
        let filepath = this.settings.folderDefaultName.length > 0 ? this.settings.folderDefaultName + "/" + file.path : file.path;
        if (frontMatter && frontMatter[shareKey] === true) {
          if (this.settings.downloadedFolder === "yamlFrontmatter") {
            if (frontMatter[this.settings.yamlFolderKey]) {
              filepath = this.settings.rootFolder.length > 0 ? this.settings.rootFolder + "/" + frontMatter[this.settings.yamlFolderKey] + "/" + file.name : file.name;
            }
          } else if (this.settings.downloadedFolder === "fixedFolder") {
            filepath = this.settings.folderDefaultName.length > 0 ? this.settings.folderDefaultName + "/" + file.name : file.name;
          }
          allFileWithPath.push(filepath);
        }
      }
    }
    return allFileWithPath;
  }
  getLinkedImage(file) {
    const embed_files = this.metadataCache.getCache(file.path).embeds;
    const image_list = [];
    if (embed_files != void 0) {
      for (const embed_file of embed_files) {
        try {
          const imageLink = this.metadataCache.getFirstLinkpathDest(embed_file.link, file.path);
          const imgExt = imageLink.extension;
          if (imgExt.match(/(png|jpe?g|svg|bmp|gif)$/i)) {
            image_list.push(imageLink);
          }
        } catch (e) {
          console.log("Error with this image : " + embed_file);
        }
      }
      return image_list;
    }
    return [];
  }
  checkExcludedFolder(file) {
    const excludedFolder = this.settings.ExcludedFolder.split(",").filter((x) => x != "");
    if (excludedFolder.length > 0) {
      for (let i = 0; i < excludedFolder.length; i++) {
        if (file.path.contains(excludedFolder[i].trim())) {
          return true;
        }
      }
    }
    return false;
  }
};

// node_modules/js-base64/base64.mjs
var version = "3.7.2";
var VERSION = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// mkdocsPublisher/githubInteraction/delete.ts
var import_obsidian2 = __toModule(require("obsidian"));
function deleteFromGithub(silent = false, settings, octokit, branchName = "main", GetFiles2) {
  return __async(this, null, function* () {
    const getAllFile = yield getAllFileFromRepo(branchName, octokit, settings);
    const filesInRepo = yield filterGithubFile(getAllFile, settings);
    if (!filesInRepo) {
      let errorMsg = "";
      if (settings.folderDefaultName.length > 0) {
        if (settings.folderDefaultName.length > 0) {
          errorMsg = "You need to configure a default folder name in the settings to use this command.";
        } else if (settings.downloadedFolder === "yamlFrontmatter" && settings.rootFolder) {
          errorMsg = "You need to configure a root folder in the settings to use this command.";
        }
        if (!silent) {
          new import_obsidian2.Notice("Error : " + errorMsg);
        }
      }
      return false;
    }
    const allSharedFiles = GetFiles2.getAllFileWithPath();
    let deletedSuccess = 0;
    let deletedFailed = 0;
    for (const file of filesInRepo) {
      if (!allSharedFiles.includes(file.file)) {
        try {
          console.log("trying to delete file : " + file.file);
          const reponse = yield octokit.request("DELETE /repos/{owner}/{repo}/contents/{path}", {
            owner: settings.githubName,
            repo: settings.githubRepo,
            path: file.file,
            message: "Delete file",
            sha: file.sha,
            branch: branchName
          });
          if (reponse.status === 200) {
            deletedSuccess++;
          } else {
            deletedFailed++;
          }
        } catch (e) {
          console.error(e);
        }
      }
    }
    let successMsg = "No files have been deleted";
    let failedMsg = "";
    if (deletedSuccess > 0) {
      successMsg = `Successfully deleted ${deletedSuccess} files`;
    }
    if (deletedFailed > 0) {
      failedMsg = `Failed to delete ${deletedFailed} files.`;
    }
    if (!silent) {
      new import_obsidian2.Notice(successMsg + failedMsg);
    }
    return true;
  });
}
function excludedFileFromDelete(file, settings) {
  const autoCleanExcluded = settings.autoCleanUpExcluded.split(",");
  if (autoCleanExcluded.length > 0) {
    for (const excludedFile of autoCleanExcluded) {
      if (file.includes(excludedFile) && excludedFile.length > 0) {
        return true;
      }
    }
  }
  return false;
}
function filterGithubFile(fileInRepo, settings) {
  return __async(this, null, function* () {
    const sharedFilesInRepo = [];
    for (const file of fileInRepo) {
      if (settings.downloadedFolder === "yamlFrontmatter" && settings.rootFolder.length === 0 || settings.folderDefaultName.length === 0) {
        return false;
      }
      if ((file.file.includes(settings.folderDefaultName) || settings.downloadedFolder === "yamlFrontmatter" && file.file.includes(settings.rootFolder) || settings.defaultImageFolder.length > 0 && file.file.includes(settings.defaultImageFolder)) && !excludedFileFromDelete(file.file, settings) && file.file.match(/(md|jpe?g|png|gif|bmp|svg|mp3|webm|wav|m4a|ogg|3gp|flac|mp4|ogv|pdf)$/)) {
        sharedFilesInRepo.push(file);
      }
    }
    return sharedFilesInRepo;
  });
}
function getAllFileFromRepo(ref = "main", octokit, settings) {
  return __async(this, null, function* () {
    const filesInRepo = [];
    try {
      const repoContents = yield octokit.request("GET /repos/{owner}/{repo}/git/trees/{tree_sha}", {
        owner: settings.githubName,
        repo: settings.githubRepo,
        tree_sha: ref,
        recursive: "true"
      });
      if (repoContents.status === 200) {
        const files = repoContents.data.tree;
        for (const file of files) {
          const basename = (name) => /([^/\\.]*)(\..*)?$/.exec(name)[1];
          if (file.type === "blob" && basename(file.path).length > 0 && basename(file.path) != "vault_published") {
            filesInRepo.push({
              file: file.path,
              sha: file.sha
            });
          }
        }
      }
    } catch (e) {
      console.log(e);
    }
    return filesInRepo;
  });
}

// mkdocsPublisher/githubInteraction/upload.ts
var MkdocsPublish = class {
  constructor(vault, metadataCache, settings, octokit) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings;
    this.octokit = octokit;
  }
  publish(file, one_file = false, ref = "main") {
    return __async(this, null, function* () {
      const shareFiles = new GetFiles(this.vault, this.metadataCache, this.settings, this.octokit);
      const sharedKey = this.settings.shareKey;
      const frontmatter = this.metadataCache.getCache(file.path).frontmatter;
      if (!frontmatter || !frontmatter[sharedKey] || shareFiles.checkExcludedFolder(file) || file.extension !== "md") {
        return false;
      }
      try {
        const text = yield this.vault.cachedRead(file);
        const linkedImage = shareFiles.getLinkedImage(file);
        let folderDefault = this.settings.folderDefaultName;
        if (folderDefault.length > 0) {
          folderDefault = folderDefault + "/";
        }
        let path = folderDefault + file.name;
        if (this.settings.downloadedFolder === "yamlFrontmatter") {
          let folderRoot = this.settings.rootFolder;
          if (folderRoot.length > 0) {
            folderRoot = folderRoot + "/";
          }
          if (frontmatter[this.settings.yamlFolderKey]) {
            path = folderRoot + frontmatter[this.settings.yamlFolderKey] + "/" + file.name;
          }
        } else if (this.settings.downloadedFolder === "obsidianPath") {
          path = folderDefault + file.path;
        }
        yield this.uploadText(file.path, text, path, file.name, ref);
        if (linkedImage.length > 0 && this.settings.transferEmbedded) {
          for (const image of linkedImage) {
            yield this.uploadImage(image, ref);
          }
        }
        if (one_file) {
          yield this.uploadFolder(ref);
          yield deleteFromGithub(true, this.settings, this.octokit, ref, shareFiles);
        }
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    });
  }
  uploadFolder(ref = "main") {
    return __async(this, null, function* () {
      const shareFiles = new GetFiles(this.vault, this.metadataCache, this.settings, this.octokit);
      const folder = shareFiles.getSharedFiles();
      if (folder.length > 0) {
        const publishedFiles = folder.map((file) => file.name);
        const publishedFilesText = JSON.stringify(publishedFiles).toString();
        const vaultPublisherJSON = this.settings.folderDefaultName.length > 0 ? `${this.settings.folderDefaultName}/vault_published.json` : `vault_published.json`;
        yield this.uploadText("vault_published.json", publishedFilesText, vaultPublisherJSON, "", ref);
      }
    });
  }
  upload(filePath, content, path, title = "", ref = "main") {
    return __async(this, null, function* () {
      if (!this.settings.githubRepo) {
        new import_obsidian3.Notice("Config error : You need to define a github repo in the plugin settings");
        throw {};
      }
      if (!this.settings.githubName) {
        new import_obsidian3.Notice("Config error : You need to define your github username in the plugin settings");
        throw {};
      }
      const octokit = this.octokit;
      const payload = {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        path,
        message: `Adding ${title}`,
        content,
        sha: "",
        branch: ref
      };
      try {
        const response = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo,
          path,
          ref
        });
        if (response.status === 200 && response.data.type === "file") {
          payload.sha = response.data.sha;
        }
      } catch (e) {
        console.log("The 404 error is normal ! It means that the file does not exist yet. Don't worry \u2764\uFE0F.");
      }
      payload.message = `Update note ${title}`;
      yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", payload);
    });
  }
  uploadImage(imageFile, ref = "main") {
    return __async(this, null, function* () {
      const imageBin = yield this.vault.readBinary(imageFile);
      const image64 = (0, import_obsidian3.arrayBufferToBase64)(imageBin);
      let path = this.settings.folderDefaultName + "/" + imageFile.name;
      if (this.settings.defaultImageFolder.length > 0) {
        path = this.settings.defaultImageFolder + "/" + imageFile.name;
      }
      yield this.upload(imageFile.path, image64, path, "", ref);
    });
  }
  uploadText(filePath, text, path, title = "", ref = "main") {
    return __async(this, null, function* () {
      try {
        const contentBase64 = gBase64.encode(text).toString();
        yield this.upload(filePath, contentBase64, path, title, ref);
      } catch (e) {
        console.error(e);
      }
    });
  }
  workflowGestion() {
    return __async(this, null, function* () {
      let finished = false;
      if (this.settings.workflowName.length === 0) {
        return false;
      } else {
        const octokit = this.octokit;
        yield octokit.request("POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches", {
          owner: this.settings.githubName,
          repo: this.settings.githubRepo,
          workflow_id: this.settings.workflowName,
          ref: "main"
        });
        while (!finished) {
          yield sleep(1e4);
          const workflowGet = yield octokit.request("GET /repos/{owner}/{repo}/actions/runs", {
            owner: this.settings.githubName,
            repo: this.settings.githubRepo
          });
          if (workflowGet.data.workflow_runs.length > 0) {
            const build = workflowGet.data.workflow_runs.find((run) => run.name === this.settings.workflowName.replace(".yml", ""));
            if (build.status === "completed") {
              finished = true;
              return true;
            }
          }
        }
      }
    });
  }
};

// mkdocsPublisher/utils/utils.ts
var import_obsidian4 = __toModule(require("obsidian"));
function disablePublish(app, settings, file) {
  const fileCache = app.metadataCache.getFileCache(file);
  const meta = fileCache == null ? void 0 : fileCache.frontmatter;
  const folderList = settings.ExcludedFolder.split(",").filter((x) => x !== "");
  if (meta === void 0) {
    return false;
  } else if (folderList.length > 0) {
    for (let i = 0; i < folderList.length; i++) {
      if (file.path.contains(folderList[i].trim())) {
        return false;
      }
    }
  }
  return meta[settings.shareKey];
}
function noticeMessage(publish, file, settings) {
  return __async(this, null, function* () {
    const noticeValue = file instanceof import_obsidian4.TFile ? '"' + file.basename + '"' : file;
    const msg = settings.workflowName.length > 0 ? ".\nNow, waiting for the workflow to be completed..." : ".";
    new import_obsidian4.Notice("Send " + noticeValue + " to " + settings.githubRepo + msg);
    const successWorkflow = yield publish.workflowGestion();
    if (successWorkflow) {
      new import_obsidian4.Notice("Successfully published " + noticeValue + " to " + settings.githubRepo + ".");
    }
  });
}

// mkdocsPublisher/settings/interface.ts
var DEFAULT_SETTINGS = {
  githubRepo: "",
  githubName: "",
  GhToken: "",
  shareKey: "share",
  ExcludedFolder: "",
  fileMenu: false,
  editorMenu: false,
  downloadedFolder: "fixedFolder",
  folderDefaultName: "",
  yamlFolderKey: "",
  rootFolder: "",
  workflowName: "",
  transferEmbedded: true,
  defaultImageFolder: "",
  autoCleanUp: false,
  autoCleanUpExcluded: ""
};

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/core/dist-web/index.js
var import_before_after_hook = __toModule(require_before_after_hook());

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/@octokit/endpoint/dist-web/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }
  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var VERSION2 = "6.0.12";
var userAgent = `octokit-endpoint.js/${VERSION2} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-web/index.js
var import_node_fetch = __toModule(require_browser());

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toModule(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION3 = "5.6.3";
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || import_node_fetch.default;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then((response) => __async(this, null, function* () {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: yield getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = yield getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return getResponseData(response);
  })).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    throw new RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}
function getResponseData(response) {
  return __async(this, null, function* () {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  });
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION3} ${getUserAgent()}`
  }
});

// node_modules/@octokit/graphql/dist-web/index.js
var VERSION4 = "4.8.0";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: request.endpoint
  });
}
var graphql$1 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION4} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-web/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
function auth(token) {
  return __async(this, null, function* () {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  });
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
function hook(token, request2, route, parameters) {
  return __async(this, null, function* () {
    const endpoint2 = request2.endpoint.merge(route, parameters);
    endpoint2.headers.authorization = withAuthorizationPrefix(token);
    return request2(endpoint2);
  });
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-web/index.js
var VERSION5 = "3.6.0";
var Octokit = class {
  constructor(options = {}) {
    const hook2 = new import_before_after_hook.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = [
      options.userAgent,
      `octokit-core.js/${VERSION5} ${getUserAgent()}`
    ].filter(Boolean).join(" ");
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = () => __async(this, null, function* () {
          return {
            type: "unauthenticated"
          };
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const _a = options, { authStrategy } = _a, otherOptions = __objRest(_a, ["authStrategy"]);
      const auth2 = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth));
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    classConstructor.plugins.forEach((plugin) => {
      Object.assign(this, plugin(this, options));
    });
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }
    };
    return OctokitWithDefaults;
  }
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }
};
Octokit.VERSION = VERSION5;
Octokit.plugins = [];

// mkdocsPublisher/githubInteraction/branch.ts
var GithubBranch = class {
  constructor(settings, octokit) {
    this.settings = settings;
    this.octokit = octokit;
  }
  newBranch(branchName) {
    return __async(this, null, function* () {
      const allBranch = yield this.octokit.request("GET /repos/{owner}/{repo}/branches", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo
      });
      const mainBranch = allBranch.data.find((branch2) => branch2.name === "main" || branch2.name === "master");
      const shaMainBranch = mainBranch.commit.sha;
      const branch = yield this.octokit.request("POST /repos/{owner}/{repo}/git/refs", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        ref: "refs/heads/" + branchName,
        sha: shaMainBranch
      });
      return branch.status === 201;
    });
  }
  pullRequest(branchName) {
    return __async(this, null, function* () {
      return yield this.octokit.request("POST /repos/{owner}/{repo}/pulls", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        title: `PullRequest ${branchName} from Obsidian`,
        body: "",
        head: branchName,
        base: "main"
      });
    });
  }
  deleteBranch(branchName) {
    return __async(this, null, function* () {
      const octokit = new Octokit({
        auth: this.settings.GhToken
      });
      const branch = yield octokit.request("DELETE /repos/{owner}/{repo}/git/refs/heads/" + branchName, {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo
      });
      return branch.status === 200;
    });
  }
  mergePullRequest(branchName, silent = false, pullRequestNumber) {
    return __async(this, null, function* () {
      const octokit = new Octokit({
        auth: this.settings.GhToken
      });
      const branch = yield octokit.request("PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge", {
        owner: this.settings.githubName,
        repo: this.settings.githubRepo,
        pull_number: pullRequestNumber,
        state: "closed"
      });
      return branch.status === 200;
    });
  }
  updateRepository(branchName) {
    return __async(this, null, function* () {
      const pullRequest = yield this.pullRequest(branchName);
      yield this.mergePullRequest(branchName, true, pullRequest.data.number);
      yield this.deleteBranch(branchName);
      return true;
    });
  }
};

// mkdocsPublisher/main.ts
var MkdocsPublication = class extends import_obsidian5.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("Mkdocs Publication loaded");
      yield this.loadSettings();
      this.addSettingTab(new MkdocsSettingsTab(this.app, this));
      const octokit = new Octokit({ auth: this.settings.GhToken });
      const publish = new MkdocsPublish(this.app.vault, this.app.metadataCache, this.settings, octokit);
      const githubBranch = new GithubBranch(this.settings, octokit);
      const shareFiles = new GetFiles(this.app.vault, this.app.metadataCache, this.settings, octokit);
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (disablePublish(this.app, this.settings, file) && this.settings.fileMenu) {
          menu.addSeparator();
          menu.addItem((item) => {
            item.setTitle('Share "' + file.basename + '" with Mkdocs Publisher').setIcon("share").onClick(() => __async(this, null, function* () {
              try {
                const branchName = this.app.vault.getName() + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
                yield githubBranch.newBranch(branchName);
                const publishSuccess = yield publish.publish(file, true, branchName);
                if (publishSuccess) {
                  const update = yield githubBranch.updateRepository(branchName);
                  if (update) {
                    yield noticeMessage(publish, file, this.settings);
                  }
                }
              } catch (e) {
                console.error(e);
                new import_obsidian5.Notice("Error publishing to " + this.settings.githubRepo + ".");
              }
            }));
          });
          menu.addSeparator();
        }
      }));
      this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (disablePublish(this.app, this.settings, view.file) && this.settings.editorMenu) {
          menu.addSeparator();
          menu.addItem((item) => {
            item.setTitle('Share "' + view.file.basename + '" with Mkdocs Publisher').setIcon("share").onClick(() => __async(this, null, function* () {
              try {
                const branchName = this.app.vault.getName() + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
                yield githubBranch.newBranch(branchName);
                const publishSuccess = yield publish.publish(view.file, true, branchName);
                if (publishSuccess) {
                  const update = yield githubBranch.updateRepository(branchName);
                  if (update) {
                    yield noticeMessage(publish, view.file, this.settings);
                  } else {
                    new import_obsidian5.Notice("Error publishing to " + this.settings.githubRepo + ".");
                  }
                }
              } catch (e) {
                console.error(e);
                new import_obsidian5.Notice("Error publishing to " + this.settings.githubRepo + ".");
              }
            }));
          });
        }
      }));
      this.addCommand({
        id: "obs2mk-one",
        name: "Share active file with Mkdocs Publisher",
        hotkeys: [],
        checkCallback: (checking) => {
          if (disablePublish(this.app, this.settings, this.app.workspace.getActiveFile())) {
            if (!checking) {
              try {
                const { workspace } = this.app;
                const currentFile = workspace.getActiveFile();
                const branchName = this.app.vault.getName() + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
                const githubBranch2 = new GithubBranch(this.settings, octokit);
                githubBranch2.newBranch(branchName);
                const publishSuccess = publish.publish(currentFile, true, branchName);
                if (publishSuccess) {
                  const update = githubBranch2.updateRepository(branchName);
                  if (update) {
                    noticeMessage(publish, currentFile, this.settings);
                  } else {
                    new import_obsidian5.Notice("Error publishing to " + this.settings.githubRepo + ".");
                  }
                }
              } catch (e) {
                console.error(e);
                new import_obsidian5.Notice("Error publishing to github.");
              }
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "Obs2MK-delete-clean",
        name: "Delete from repository",
        hotkeys: [],
        checkCallback: (checking) => {
          if (this.settings.autoCleanUp) {
            if (!checking) {
              try {
                new import_obsidian5.Notice(`Starting cleaning ${this.settings.githubRepo} `);
                const branchName = this.app.vault.getName() + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
                githubBranch.newBranch(branchName);
                deleteFromGithub(false, this.settings, octokit, branchName, shareFiles);
                githubBranch.updateRepository(branchName);
              } catch (e) {
                console.error(e);
              }
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "obs2mk-publish-all",
        name: "Share all marked notes",
        callback: () => __async(this, null, function* () {
          const statusBarItems = this.addStatusBarItem();
          try {
            const sharedFiles = shareFiles.getSharedFiles();
            const statusBar = new ShareStatusBar(statusBarItems, sharedFiles.length);
            let errorCount = 0;
            if (sharedFiles.length > 0) {
              const publishedFiles = sharedFiles.map((file) => file.name);
              const publishedFilesText = JSON.stringify(publishedFiles).toString();
              const githubBranch2 = new GithubBranch(this.settings, octokit);
              const branchName = this.app.vault.getName() + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
              yield githubBranch2.newBranch(branchName);
              const vaultPublisherJSON = this.settings.folderDefaultName.length > 0 ? `${this.settings.folderDefaultName}/vault_published.json` : `vault_published.json`;
              yield publish.uploadText("vault_published.json", publishedFilesText, vaultPublisherJSON, "", branchName);
              for (let files = 0; files < sharedFiles.length; files++) {
                try {
                  const file = sharedFiles[files];
                  statusBar.increment();
                  yield publish.publish(file, false, branchName);
                } catch (e) {
                  errorCount++;
                  new import_obsidian5.Notice(`Unable to publish note ${sharedFiles[files].name}, skipping it`);
                }
              }
              statusBar.finish(8e3);
              const noticeValue = `${publishedFiles.length - errorCount} notes`;
              yield deleteFromGithub(true, this.settings, octokit, branchName, shareFiles);
              const update = yield githubBranch2.updateRepository(branchName);
              if (update) {
                yield noticeMessage(publish, noticeValue, this.settings);
              } else {
                new import_obsidian5.Notice("Error publishing to " + this.settings.githubRepo + ".");
              }
            }
          } catch (e) {
            console.error(e);
            new import_obsidian5.Notice("Unable to publish multiple notes, something went wrong.");
          }
        })
      });
    });
  }
  onunload() {
    console.log("Github Publisher unloaded");
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
